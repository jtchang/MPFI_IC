"""Collection of useful methods for interacting with ScanImage tif files generated by ScanImage2015.

Todo:
    Support multiple versions of scanimage
"""

import json
from collections import defaultdict
from pathlib import Path

import numpy as np
from PIL import Image
import skimage.io as io
import tifffile


def read_si_tiffstack(path_name: str, header_only: bool = False) -> tuple:
    """Open a scanimage tiff file

    Reads header data using PIL and tiff image data using scikit-image.

    Todo:
        Using two libraries is inefficient, finding a single solution would be the best.

    Args:
        path_name (str): Path to a tif file
        header_only (bool): flag to parse header only and return no image data
    Returns:
        tuple: Image Data (numpy.ndarray (z,y,x)), header (dict)
    """
    # convert any windows style
    if not isinstance(path_name, Path):
        file_to_open = Path(path_name)
    else:
        file_to_open = path_name
    assert file_to_open.exists(), 'File does not exist!'

    img = tifffile.TiffFile(file_to_open)
    if img.is_bigtiff:
        header = parse_si_header(img.scanimage_metadata['FrameData'])
    else:
        header = parse_si_header(img.scanimage_metadata['Description'])

    if not header_only:
        img_data = img.asarray()
    else:
        img_data = None
    return img_data, header


def parse_si_header(header) -> dict:
    """Cleans ScanImage header information into a useable format.

    Args:
        header (str or dict): ScanImage header information

    Returns:
        dict: ScanImage header information as a useable dict.
    """

    assert isinstance(header, str) or isinstance(header, dict), 'Please provide a str or dict!'
    if isinstance(header, str):
        raise NotImplementedError("No longer supports parsing of strings, use tifffile instead")
    elif isinstance(header, dict):
        return _parse_dict(header)
    return None


def to_json(header: dict, filename: str):
    """Writes header information into a json file
    Args:
        header (dict): ScanImage header as a dictionary.
        filename (str): Filepath to write to.
    """

    with open(filename, 'w') as fid:
        json.dump(header, fid)


def _parse_dict(header: dict) ->dict:
    """Makes header information consistent between scanimage file version 1 and 3.

    Strips the scanimage tag from header information for consistency

    Args:
        header (dict): header information from tifffile.scanimage_metadata

    Returns:
        dict: rectified header information
    """
    new_dict = {}
    for key, val in header.items():
        all_keys = key.split('.')
        if all_keys[0] == 'scanimage':
            new_key = ('.').join(all_keys[1:])
        else:
            new_key = key
        new_dict[new_key] = val
    return new_dict


def si_version(header: dict)->str:
    """Returns SI version.

    Todo:
        Parse header dict for ScanImage version
    Args:
        header (dict): Header information as dict
    """
    return header['SI.VERSION_MAJOR']


def si_file_version(header: dict)->int:
    """Returns the tif file type from scanimage.

    Args:
        header (dict): cleansed scanimage header information

    Returns:
        int: tiff formate type
    """
    return header['SI.TIFF_FORMAT_VERSION']


def piezo_slices(header: dict) -> int:
    """Reads ScanImage header and returns the number of z slices.
    Args:
        header (dict): ScanImage header

    Raises:
        ValueError: Raised if ScanImage headers are not 2015.

    Returns:
        int: Number of piezo planes.
    """
    file_version_num = si_file_version(header)
    if file_version_num == 1 or file_version_num == 3:
        if header['SI.hFastZ.enable'] is 1:
            return int(header['SI.hFastZ.numFramesPerVolume'])
        else:
            return 1
    else:
        raise ValueError('Only parsing for Scanimage 2015 & 2018a is available at the moment')


def channels(header: dict)-> np.array:
    """Returns a list of active channels acquired.

    Args:
        header (dict): ScanImage header information.

    Raises:
        ValueError: Raised if ScanImage headers are not 2015

    Returns:
        np.array: List of active channels.
    """
    file_version_num = si_file_version(header)
    if file_version_num == 1 or file_version_num == 3:
        channel_list = str(header['SI.hChannels.channelSave'])
        channel_list = ''.join(x for x in channel_list if x not in '[]')
        return np.fromstring(channel_list, dtype=int, sep=';')
    else:
        raise ValueError('Only parsing for Scanimage 2015 is available at the moment')


def frames_per_file(header: dict) -> int:
    """Returns the frames logged per file from ScanImage header.

    Args:
        header (dict): ScanImage header

    Raises:
        ValueError: Raised if ScanImage headers are not 2015

    Returns:
        int: Number of frames per file.
    """

    file_version_num = si_file_version(header)
    if file_version_num == 1:
        return int(header['SI.hResScan.logFramesPerFile'])
    elif file_version_num == 3:
        return int(header['SI.hScan2D.logFramesPerFile'])
    else:
        raise ValueError('Only parsing for Scanimage 2015 & 2018a is available at the moment')
